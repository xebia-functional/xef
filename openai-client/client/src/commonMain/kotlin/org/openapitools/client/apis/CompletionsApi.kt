/**
 * Please note: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
@file:Suppress("ArrayInDataClass", "EnumEntryName", "RemoveRedundantQualifierName", "UnusedImport")

package org.openapitools.client.apis

import com.xebia.functional.openai.model.CreateCompletionRequest
import com.xebia.functional.openai.model.CreateCompletionResponse
import java.io.IOException
import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.Success

class CompletionsApi(
  basePath: kotlin.String = defaultBasePath,
  client: OkHttpClient = ApiClient.defaultClient
) : ApiClient(basePath, client) {
  companion object {
    @JvmStatic
    val defaultBasePath: String by lazy {
      System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.openai.com/v1")
    }
  }

  /**
   * Creates a completion for the provided prompt and parameters.
   *
   * @param createCompletionRequest
   * @return CreateCompletionResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun createCompletion(createCompletionRequest: CreateCompletionRequest): CreateCompletionResponse {
    val localVarResponse =
      createCompletionWithHttpInfo(createCompletionRequest = createCompletionRequest)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as CreateCompletionResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Creates a completion for the provided prompt and parameters.
   *
   * @param createCompletionRequest
   * @return ApiResponse<CreateCompletionResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun createCompletionWithHttpInfo(
    createCompletionRequest: CreateCompletionRequest
  ): ApiResponse<CreateCompletionResponse?> {
    val localVariableConfig =
      createCompletionRequestConfig(createCompletionRequest = createCompletionRequest)

    return request<CreateCompletionRequest, CreateCompletionResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation createCompletion
   *
   * @param createCompletionRequest
   * @return RequestConfig
   */
  fun createCompletionRequestConfig(
    createCompletionRequest: CreateCompletionRequest
  ): RequestConfig<CreateCompletionRequest> {
    val localVariableBody = createCompletionRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path = "/completions",
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
    HttpUrl.Builder()
      .scheme("http")
      .host("localhost")
      .addPathSegment(uriComponent)
      .build()
      .encodedPathSegments[0]
}
