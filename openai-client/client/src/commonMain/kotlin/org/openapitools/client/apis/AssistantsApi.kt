/**
 * Please note: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
@file:Suppress("ArrayInDataClass", "EnumEntryName", "RemoveRedundantQualifierName", "UnusedImport")

package org.openapitools.client.apis

import com.xebia.functional.openai.model.AssistantFileObject
import com.xebia.functional.openai.model.AssistantObject
import com.xebia.functional.openai.model.CreateAssistantFileRequest
import com.xebia.functional.openai.model.CreateAssistantRequest
import com.xebia.functional.openai.model.CreateMessageRequest
import com.xebia.functional.openai.model.CreateRunRequest
import com.xebia.functional.openai.model.CreateThreadAndRunRequest
import com.xebia.functional.openai.model.CreateThreadRequest
import com.xebia.functional.openai.model.DeleteAssistantFileResponse
import com.xebia.functional.openai.model.DeleteAssistantResponse
import com.xebia.functional.openai.model.DeleteThreadResponse
import com.xebia.functional.openai.model.ListAssistantFilesResponse
import com.xebia.functional.openai.model.ListAssistantsResponse
import com.xebia.functional.openai.model.ListMessageFilesResponse
import com.xebia.functional.openai.model.ListMessagesResponse
import com.xebia.functional.openai.model.ListRunStepsResponse
import com.xebia.functional.openai.model.ListRunsResponse
import com.xebia.functional.openai.model.MessageFileObject
import com.xebia.functional.openai.model.MessageObject
import com.xebia.functional.openai.model.ModifyAssistantRequest
import com.xebia.functional.openai.model.ModifyMessageRequest
import com.xebia.functional.openai.model.ModifyRunRequest
import com.xebia.functional.openai.model.ModifyThreadRequest
import com.xebia.functional.openai.model.RunObject
import com.xebia.functional.openai.model.RunStepObject
import com.xebia.functional.openai.model.SubmitToolOutputsRunRequest
import com.xebia.functional.openai.model.ThreadObject
import java.io.IOException
import kotlinx.serialization.SerialName
import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.Success

class AssistantsApi(
  basePath: kotlin.String = defaultBasePath,
  client: OkHttpClient = ApiClient.defaultClient
) : ApiClient(basePath, client) {
  companion object {
    @JvmStatic
    val defaultBasePath: String by lazy {
      System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.openai.com/v1")
    }
  }

  /**
   * Cancels a run that is &#x60;in_progress&#x60;.
   *
   * @param threadId The ID of the thread to which this run belongs.
   * @param runId The ID of the run to cancel.
   * @return RunObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun cancelRun(threadId: kotlin.String, runId: kotlin.String): RunObject {
    val localVarResponse = cancelRunWithHttpInfo(threadId = threadId, runId = runId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Cancels a run that is &#x60;in_progress&#x60;.
   *
   * @param threadId The ID of the thread to which this run belongs.
   * @param runId The ID of the run to cancel.
   * @return ApiResponse<RunObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun cancelRunWithHttpInfo(
    threadId: kotlin.String,
    runId: kotlin.String
  ): ApiResponse<RunObject?> {
    val localVariableConfig = cancelRunRequestConfig(threadId = threadId, runId = runId)

    return request<Unit, RunObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation cancelRun
   *
   * @param threadId The ID of the thread to which this run belongs.
   * @param runId The ID of the run to cancel.
   * @return RequestConfig
   */
  fun cancelRunRequestConfig(threadId: kotlin.String, runId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/threads/{thread_id}/runs/{run_id}/cancel"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "run_id" + "}", encodeURIComponent(runId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Create an assistant with a model and instructions.
   *
   * @param createAssistantRequest
   * @return AssistantObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun createAssistant(createAssistantRequest: CreateAssistantRequest): AssistantObject {
    val localVarResponse =
      createAssistantWithHttpInfo(createAssistantRequest = createAssistantRequest)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as AssistantObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Create an assistant with a model and instructions.
   *
   * @param createAssistantRequest
   * @return ApiResponse<AssistantObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun createAssistantWithHttpInfo(
    createAssistantRequest: CreateAssistantRequest
  ): ApiResponse<AssistantObject?> {
    val localVariableConfig =
      createAssistantRequestConfig(createAssistantRequest = createAssistantRequest)

    return request<CreateAssistantRequest, AssistantObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation createAssistant
   *
   * @param createAssistantRequest
   * @return RequestConfig
   */
  fun createAssistantRequestConfig(
    createAssistantRequest: CreateAssistantRequest
  ): RequestConfig<CreateAssistantRequest> {
    val localVariableBody = createAssistantRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path = "/assistants",
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Create an assistant file by attaching a [File](/docs/api-reference/files) to an
   * [assistant](/docs/api-reference/assistants).
   *
   * @param assistantId The ID of the assistant for which to create a File.
   * @param createAssistantFileRequest
   * @return AssistantFileObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun createAssistantFile(
    assistantId: kotlin.String,
    createAssistantFileRequest: CreateAssistantFileRequest
  ): AssistantFileObject {
    val localVarResponse =
      createAssistantFileWithHttpInfo(
        assistantId = assistantId,
        createAssistantFileRequest = createAssistantFileRequest
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as AssistantFileObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Create an assistant file by attaching a [File](/docs/api-reference/files) to an
   * [assistant](/docs/api-reference/assistants).
   *
   * @param assistantId The ID of the assistant for which to create a File.
   * @param createAssistantFileRequest
   * @return ApiResponse<AssistantFileObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun createAssistantFileWithHttpInfo(
    assistantId: kotlin.String,
    createAssistantFileRequest: CreateAssistantFileRequest
  ): ApiResponse<AssistantFileObject?> {
    val localVariableConfig =
      createAssistantFileRequestConfig(
        assistantId = assistantId,
        createAssistantFileRequest = createAssistantFileRequest
      )

    return request<CreateAssistantFileRequest, AssistantFileObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation createAssistantFile
   *
   * @param assistantId The ID of the assistant for which to create a File.
   * @param createAssistantFileRequest
   * @return RequestConfig
   */
  fun createAssistantFileRequestConfig(
    assistantId: kotlin.String,
    createAssistantFileRequest: CreateAssistantFileRequest
  ): RequestConfig<CreateAssistantFileRequest> {
    val localVariableBody = createAssistantFileRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/assistants/{assistant_id}/files"
          .replace("{" + "assistant_id" + "}", encodeURIComponent(assistantId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Create a message.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
   * @param createMessageRequest
   * @return MessageObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun createMessage(
    threadId: kotlin.String,
    createMessageRequest: CreateMessageRequest
  ): MessageObject {
    val localVarResponse =
      createMessageWithHttpInfo(threadId = threadId, createMessageRequest = createMessageRequest)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as MessageObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Create a message.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
   * @param createMessageRequest
   * @return ApiResponse<MessageObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun createMessageWithHttpInfo(
    threadId: kotlin.String,
    createMessageRequest: CreateMessageRequest
  ): ApiResponse<MessageObject?> {
    val localVariableConfig =
      createMessageRequestConfig(threadId = threadId, createMessageRequest = createMessageRequest)

    return request<CreateMessageRequest, MessageObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation createMessage
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
   * @param createMessageRequest
   * @return RequestConfig
   */
  fun createMessageRequestConfig(
    threadId: kotlin.String,
    createMessageRequest: CreateMessageRequest
  ): RequestConfig<CreateMessageRequest> {
    val localVariableBody = createMessageRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/threads/{thread_id}/messages"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Create a run.
   *
   * @param threadId The ID of the thread to run.
   * @param createRunRequest
   * @return RunObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun createRun(threadId: kotlin.String, createRunRequest: CreateRunRequest): RunObject {
    val localVarResponse =
      createRunWithHttpInfo(threadId = threadId, createRunRequest = createRunRequest)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Create a run.
   *
   * @param threadId The ID of the thread to run.
   * @param createRunRequest
   * @return ApiResponse<RunObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun createRunWithHttpInfo(
    threadId: kotlin.String,
    createRunRequest: CreateRunRequest
  ): ApiResponse<RunObject?> {
    val localVariableConfig =
      createRunRequestConfig(threadId = threadId, createRunRequest = createRunRequest)

    return request<CreateRunRequest, RunObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation createRun
   *
   * @param threadId The ID of the thread to run.
   * @param createRunRequest
   * @return RequestConfig
   */
  fun createRunRequestConfig(
    threadId: kotlin.String,
    createRunRequest: CreateRunRequest
  ): RequestConfig<CreateRunRequest> {
    val localVariableBody = createRunRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/threads/{thread_id}/runs"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Create a thread.
   *
   * @param createThreadRequest (optional)
   * @return ThreadObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun createThread(createThreadRequest: CreateThreadRequest? = null): ThreadObject {
    val localVarResponse = createThreadWithHttpInfo(createThreadRequest = createThreadRequest)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ThreadObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Create a thread.
   *
   * @param createThreadRequest (optional)
   * @return ApiResponse<ThreadObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun createThreadWithHttpInfo(
    createThreadRequest: CreateThreadRequest?
  ): ApiResponse<ThreadObject?> {
    val localVariableConfig = createThreadRequestConfig(createThreadRequest = createThreadRequest)

    return request<CreateThreadRequest, ThreadObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation createThread
   *
   * @param createThreadRequest (optional)
   * @return RequestConfig
   */
  fun createThreadRequestConfig(
    createThreadRequest: CreateThreadRequest?
  ): RequestConfig<CreateThreadRequest> {
    val localVariableBody = createThreadRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path = "/threads",
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Create a thread and run it in one request.
   *
   * @param createThreadAndRunRequest
   * @return RunObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest): RunObject {
    val localVarResponse =
      createThreadAndRunWithHttpInfo(createThreadAndRunRequest = createThreadAndRunRequest)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Create a thread and run it in one request.
   *
   * @param createThreadAndRunRequest
   * @return ApiResponse<RunObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun createThreadAndRunWithHttpInfo(
    createThreadAndRunRequest: CreateThreadAndRunRequest
  ): ApiResponse<RunObject?> {
    val localVariableConfig =
      createThreadAndRunRequestConfig(createThreadAndRunRequest = createThreadAndRunRequest)

    return request<CreateThreadAndRunRequest, RunObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation createThreadAndRun
   *
   * @param createThreadAndRunRequest
   * @return RequestConfig
   */
  fun createThreadAndRunRequestConfig(
    createThreadAndRunRequest: CreateThreadAndRunRequest
  ): RequestConfig<CreateThreadAndRunRequest> {
    val localVariableBody = createThreadAndRunRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path = "/threads/runs",
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Delete an assistant.
   *
   * @param assistantId The ID of the assistant to delete.
   * @return DeleteAssistantResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun deleteAssistant(assistantId: kotlin.String): DeleteAssistantResponse {
    val localVarResponse = deleteAssistantWithHttpInfo(assistantId = assistantId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteAssistantResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Delete an assistant.
   *
   * @param assistantId The ID of the assistant to delete.
   * @return ApiResponse<DeleteAssistantResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun deleteAssistantWithHttpInfo(
    assistantId: kotlin.String
  ): ApiResponse<DeleteAssistantResponse?> {
    val localVariableConfig = deleteAssistantRequestConfig(assistantId = assistantId)

    return request<Unit, DeleteAssistantResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation deleteAssistant
   *
   * @param assistantId The ID of the assistant to delete.
   * @return RequestConfig
   */
  fun deleteAssistantRequestConfig(assistantId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.DELETE,
      path =
        "/assistants/{assistant_id}"
          .replace("{" + "assistant_id" + "}", encodeURIComponent(assistantId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Delete an assistant file.
   *
   * @param assistantId The ID of the assistant that the file belongs to.
   * @param fileId The ID of the file to delete.
   * @return DeleteAssistantFileResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun deleteAssistantFile(
    assistantId: kotlin.String,
    fileId: kotlin.String
  ): DeleteAssistantFileResponse {
    val localVarResponse =
      deleteAssistantFileWithHttpInfo(assistantId = assistantId, fileId = fileId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteAssistantFileResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Delete an assistant file.
   *
   * @param assistantId The ID of the assistant that the file belongs to.
   * @param fileId The ID of the file to delete.
   * @return ApiResponse<DeleteAssistantFileResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun deleteAssistantFileWithHttpInfo(
    assistantId: kotlin.String,
    fileId: kotlin.String
  ): ApiResponse<DeleteAssistantFileResponse?> {
    val localVariableConfig =
      deleteAssistantFileRequestConfig(assistantId = assistantId, fileId = fileId)

    return request<Unit, DeleteAssistantFileResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation deleteAssistantFile
   *
   * @param assistantId The ID of the assistant that the file belongs to.
   * @param fileId The ID of the file to delete.
   * @return RequestConfig
   */
  fun deleteAssistantFileRequestConfig(
    assistantId: kotlin.String,
    fileId: kotlin.String
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.DELETE,
      path =
        "/assistants/{assistant_id}/files/{file_id}"
          .replace("{" + "assistant_id" + "}", encodeURIComponent(assistantId.toString()))
          .replace("{" + "file_id" + "}", encodeURIComponent(fileId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Delete a thread.
   *
   * @param threadId The ID of the thread to delete.
   * @return DeleteThreadResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun deleteThread(threadId: kotlin.String): DeleteThreadResponse {
    val localVarResponse = deleteThreadWithHttpInfo(threadId = threadId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteThreadResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Delete a thread.
   *
   * @param threadId The ID of the thread to delete.
   * @return ApiResponse<DeleteThreadResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun deleteThreadWithHttpInfo(threadId: kotlin.String): ApiResponse<DeleteThreadResponse?> {
    val localVariableConfig = deleteThreadRequestConfig(threadId = threadId)

    return request<Unit, DeleteThreadResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation deleteThread
   *
   * @param threadId The ID of the thread to delete.
   * @return RequestConfig
   */
  fun deleteThreadRequestConfig(threadId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.DELETE,
      path =
        "/threads/{thread_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Retrieves an assistant.
   *
   * @param assistantId The ID of the assistant to retrieve.
   * @return AssistantObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun getAssistant(assistantId: kotlin.String): AssistantObject {
    val localVarResponse = getAssistantWithHttpInfo(assistantId = assistantId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as AssistantObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Retrieves an assistant.
   *
   * @param assistantId The ID of the assistant to retrieve.
   * @return ApiResponse<AssistantObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun getAssistantWithHttpInfo(assistantId: kotlin.String): ApiResponse<AssistantObject?> {
    val localVariableConfig = getAssistantRequestConfig(assistantId = assistantId)

    return request<Unit, AssistantObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation getAssistant
   *
   * @param assistantId The ID of the assistant to retrieve.
   * @return RequestConfig
   */
  fun getAssistantRequestConfig(assistantId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/assistants/{assistant_id}"
          .replace("{" + "assistant_id" + "}", encodeURIComponent(assistantId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Retrieves an AssistantFile.
   *
   * @param assistantId The ID of the assistant who the file belongs to.
   * @param fileId The ID of the file we&#39;re getting.
   * @return AssistantFileObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun getAssistantFile(assistantId: kotlin.String, fileId: kotlin.String): AssistantFileObject {
    val localVarResponse = getAssistantFileWithHttpInfo(assistantId = assistantId, fileId = fileId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as AssistantFileObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Retrieves an AssistantFile.
   *
   * @param assistantId The ID of the assistant who the file belongs to.
   * @param fileId The ID of the file we&#39;re getting.
   * @return ApiResponse<AssistantFileObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun getAssistantFileWithHttpInfo(
    assistantId: kotlin.String,
    fileId: kotlin.String
  ): ApiResponse<AssistantFileObject?> {
    val localVariableConfig =
      getAssistantFileRequestConfig(assistantId = assistantId, fileId = fileId)

    return request<Unit, AssistantFileObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation getAssistantFile
   *
   * @param assistantId The ID of the assistant who the file belongs to.
   * @param fileId The ID of the file we&#39;re getting.
   * @return RequestConfig
   */
  fun getAssistantFileRequestConfig(
    assistantId: kotlin.String,
    fileId: kotlin.String
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/assistants/{assistant_id}/files/{file_id}"
          .replace("{" + "assistant_id" + "}", encodeURIComponent(assistantId.toString()))
          .replace("{" + "file_id" + "}", encodeURIComponent(fileId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Retrieve a message.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message
   *   belongs.
   * @param messageId The ID of the message to retrieve.
   * @return MessageObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun getMessage(threadId: kotlin.String, messageId: kotlin.String): MessageObject {
    val localVarResponse = getMessageWithHttpInfo(threadId = threadId, messageId = messageId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as MessageObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Retrieve a message.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message
   *   belongs.
   * @param messageId The ID of the message to retrieve.
   * @return ApiResponse<MessageObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun getMessageWithHttpInfo(
    threadId: kotlin.String,
    messageId: kotlin.String
  ): ApiResponse<MessageObject?> {
    val localVariableConfig = getMessageRequestConfig(threadId = threadId, messageId = messageId)

    return request<Unit, MessageObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation getMessage
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message
   *   belongs.
   * @param messageId The ID of the message to retrieve.
   * @return RequestConfig
   */
  fun getMessageRequestConfig(
    threadId: kotlin.String,
    messageId: kotlin.String
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}/messages/{message_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "message_id" + "}", encodeURIComponent(messageId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Retrieves a message file.
   *
   * @param threadId The ID of the thread to which the message and File belong.
   * @param messageId The ID of the message the file belongs to.
   * @param fileId The ID of the file being retrieved.
   * @return MessageFileObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun getMessageFile(
    threadId: kotlin.String,
    messageId: kotlin.String,
    fileId: kotlin.String
  ): MessageFileObject {
    val localVarResponse =
      getMessageFileWithHttpInfo(threadId = threadId, messageId = messageId, fileId = fileId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as MessageFileObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Retrieves a message file.
   *
   * @param threadId The ID of the thread to which the message and File belong.
   * @param messageId The ID of the message the file belongs to.
   * @param fileId The ID of the file being retrieved.
   * @return ApiResponse<MessageFileObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun getMessageFileWithHttpInfo(
    threadId: kotlin.String,
    messageId: kotlin.String,
    fileId: kotlin.String
  ): ApiResponse<MessageFileObject?> {
    val localVariableConfig =
      getMessageFileRequestConfig(threadId = threadId, messageId = messageId, fileId = fileId)

    return request<Unit, MessageFileObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation getMessageFile
   *
   * @param threadId The ID of the thread to which the message and File belong.
   * @param messageId The ID of the message the file belongs to.
   * @param fileId The ID of the file being retrieved.
   * @return RequestConfig
   */
  fun getMessageFileRequestConfig(
    threadId: kotlin.String,
    messageId: kotlin.String,
    fileId: kotlin.String
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}/messages/{message_id}/files/{file_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "message_id" + "}", encodeURIComponent(messageId.toString()))
          .replace("{" + "file_id" + "}", encodeURIComponent(fileId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Retrieves a run.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
   * @param runId The ID of the run to retrieve.
   * @return RunObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun getRun(threadId: kotlin.String, runId: kotlin.String): RunObject {
    val localVarResponse = getRunWithHttpInfo(threadId = threadId, runId = runId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Retrieves a run.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
   * @param runId The ID of the run to retrieve.
   * @return ApiResponse<RunObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun getRunWithHttpInfo(threadId: kotlin.String, runId: kotlin.String): ApiResponse<RunObject?> {
    val localVariableConfig = getRunRequestConfig(threadId = threadId, runId = runId)

    return request<Unit, RunObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation getRun
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
   * @param runId The ID of the run to retrieve.
   * @return RequestConfig
   */
  fun getRunRequestConfig(threadId: kotlin.String, runId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}/runs/{run_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "run_id" + "}", encodeURIComponent(runId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Retrieves a run step.
   *
   * @param threadId The ID of the thread to which the run and run step belongs.
   * @param runId The ID of the run to which the run step belongs.
   * @param stepId The ID of the run step to retrieve.
   * @return RunStepObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun getRunStep(
    threadId: kotlin.String,
    runId: kotlin.String,
    stepId: kotlin.String
  ): RunStepObject {
    val localVarResponse =
      getRunStepWithHttpInfo(threadId = threadId, runId = runId, stepId = stepId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as RunStepObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Retrieves a run step.
   *
   * @param threadId The ID of the thread to which the run and run step belongs.
   * @param runId The ID of the run to which the run step belongs.
   * @param stepId The ID of the run step to retrieve.
   * @return ApiResponse<RunStepObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun getRunStepWithHttpInfo(
    threadId: kotlin.String,
    runId: kotlin.String,
    stepId: kotlin.String
  ): ApiResponse<RunStepObject?> {
    val localVariableConfig =
      getRunStepRequestConfig(threadId = threadId, runId = runId, stepId = stepId)

    return request<Unit, RunStepObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation getRunStep
   *
   * @param threadId The ID of the thread to which the run and run step belongs.
   * @param runId The ID of the run to which the run step belongs.
   * @param stepId The ID of the run step to retrieve.
   * @return RequestConfig
   */
  fun getRunStepRequestConfig(
    threadId: kotlin.String,
    runId: kotlin.String,
    stepId: kotlin.String
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}/runs/{run_id}/steps/{step_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "run_id" + "}", encodeURIComponent(runId.toString()))
          .replace("{" + "step_id" + "}", encodeURIComponent(stepId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Retrieves a thread.
   *
   * @param threadId The ID of the thread to retrieve.
   * @return ThreadObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun getThread(threadId: kotlin.String): ThreadObject {
    val localVarResponse = getThreadWithHttpInfo(threadId = threadId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ThreadObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Retrieves a thread.
   *
   * @param threadId The ID of the thread to retrieve.
   * @return ApiResponse<ThreadObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun getThreadWithHttpInfo(threadId: kotlin.String): ApiResponse<ThreadObject?> {
    val localVariableConfig = getThreadRequestConfig(threadId = threadId)

    return request<Unit, ThreadObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation getThread
   *
   * @param threadId The ID of the thread to retrieve.
   * @return RequestConfig
   */
  fun getThreadRequestConfig(threadId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /** enum for parameter order */
  enum class OrderListAssistantFiles(val value: kotlin.String) {
    @SerialName(value = "asc") asc("asc"),
    @SerialName(value = "desc") desc("desc")
  }

  /**
   * Returns a list of assistant files.
   *
   * @param assistantId The ID of the assistant the file belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ListAssistantFilesResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun listAssistantFiles(
    assistantId: kotlin.String,
    limit: kotlin.Int? = 20,
    order: OrderListAssistantFiles? = OrderListAssistantFiles.desc,
    after: kotlin.String? = null,
    before: kotlin.String? = null
  ): ListAssistantFilesResponse {
    val localVarResponse =
      listAssistantFilesWithHttpInfo(
        assistantId = assistantId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ListAssistantFilesResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns a list of assistant files.
   *
   * @param assistantId The ID of the assistant the file belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ApiResponse<ListAssistantFilesResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun listAssistantFilesWithHttpInfo(
    assistantId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListAssistantFiles?,
    after: kotlin.String?,
    before: kotlin.String?
  ): ApiResponse<ListAssistantFilesResponse?> {
    val localVariableConfig =
      listAssistantFilesRequestConfig(
        assistantId = assistantId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return request<Unit, ListAssistantFilesResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation listAssistantFiles
   *
   * @param assistantId The ID of the assistant the file belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return RequestConfig
   */
  fun listAssistantFilesRequestConfig(
    assistantId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListAssistantFiles?,
    after: kotlin.String?,
    before: kotlin.String?
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap =
      mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
        if (limit != null) {
          put("limit", listOf(limit.toString()))
        }
        if (order != null) {
          put("order", listOf(order.value))
        }
        if (after != null) {
          put("after", listOf(after.toString()))
        }
        if (before != null) {
          put("before", listOf(before.toString()))
        }
      }
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/assistants/{assistant_id}/files"
          .replace("{" + "assistant_id" + "}", encodeURIComponent(assistantId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /** enum for parameter order */
  enum class OrderListAssistants(val value: kotlin.String) {
    @SerialName(value = "asc") asc("asc"),
    @SerialName(value = "desc") desc("desc")
  }

  /**
   * Returns a list of assistants.
   *
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ListAssistantsResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun listAssistants(
    limit: kotlin.Int? = 20,
    order: OrderListAssistants? = OrderListAssistants.desc,
    after: kotlin.String? = null,
    before: kotlin.String? = null
  ): ListAssistantsResponse {
    val localVarResponse =
      listAssistantsWithHttpInfo(limit = limit, order = order, after = after, before = before)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ListAssistantsResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns a list of assistants.
   *
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ApiResponse<ListAssistantsResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun listAssistantsWithHttpInfo(
    limit: kotlin.Int?,
    order: OrderListAssistants?,
    after: kotlin.String?,
    before: kotlin.String?
  ): ApiResponse<ListAssistantsResponse?> {
    val localVariableConfig =
      listAssistantsRequestConfig(limit = limit, order = order, after = after, before = before)

    return request<Unit, ListAssistantsResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation listAssistants
   *
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return RequestConfig
   */
  fun listAssistantsRequestConfig(
    limit: kotlin.Int?,
    order: OrderListAssistants?,
    after: kotlin.String?,
    before: kotlin.String?
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap =
      mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
        if (limit != null) {
          put("limit", listOf(limit.toString()))
        }
        if (order != null) {
          put("order", listOf(order.value))
        }
        if (after != null) {
          put("after", listOf(after.toString()))
        }
        if (before != null) {
          put("before", listOf(before.toString()))
        }
      }
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path = "/assistants",
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /** enum for parameter order */
  enum class OrderListMessageFiles(val value: kotlin.String) {
    @SerialName(value = "asc") asc("asc"),
    @SerialName(value = "desc") desc("desc")
  }

  /**
   * Returns a list of message files.
   *
   * @param threadId The ID of the thread that the message and files belong to.
   * @param messageId The ID of the message that the files belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ListMessageFilesResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun listMessageFiles(
    threadId: kotlin.String,
    messageId: kotlin.String,
    limit: kotlin.Int? = 20,
    order: OrderListMessageFiles? = OrderListMessageFiles.desc,
    after: kotlin.String? = null,
    before: kotlin.String? = null
  ): ListMessageFilesResponse {
    val localVarResponse =
      listMessageFilesWithHttpInfo(
        threadId = threadId,
        messageId = messageId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ListMessageFilesResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns a list of message files.
   *
   * @param threadId The ID of the thread that the message and files belong to.
   * @param messageId The ID of the message that the files belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ApiResponse<ListMessageFilesResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun listMessageFilesWithHttpInfo(
    threadId: kotlin.String,
    messageId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListMessageFiles?,
    after: kotlin.String?,
    before: kotlin.String?
  ): ApiResponse<ListMessageFilesResponse?> {
    val localVariableConfig =
      listMessageFilesRequestConfig(
        threadId = threadId,
        messageId = messageId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return request<Unit, ListMessageFilesResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation listMessageFiles
   *
   * @param threadId The ID of the thread that the message and files belong to.
   * @param messageId The ID of the message that the files belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return RequestConfig
   */
  fun listMessageFilesRequestConfig(
    threadId: kotlin.String,
    messageId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListMessageFiles?,
    after: kotlin.String?,
    before: kotlin.String?
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap =
      mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
        if (limit != null) {
          put("limit", listOf(limit.toString()))
        }
        if (order != null) {
          put("order", listOf(order.value))
        }
        if (after != null) {
          put("after", listOf(after.toString()))
        }
        if (before != null) {
          put("before", listOf(before.toString()))
        }
      }
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}/messages/{message_id}/files"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "message_id" + "}", encodeURIComponent(messageId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /** enum for parameter order */
  enum class OrderListMessages(val value: kotlin.String) {
    @SerialName(value = "asc") asc("asc"),
    @SerialName(value = "desc") desc("desc")
  }

  /**
   * Returns a list of messages for a given thread.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ListMessagesResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun listMessages(
    threadId: kotlin.String,
    limit: kotlin.Int? = 20,
    order: OrderListMessages? = OrderListMessages.desc,
    after: kotlin.String? = null,
    before: kotlin.String? = null
  ): ListMessagesResponse {
    val localVarResponse =
      listMessagesWithHttpInfo(
        threadId = threadId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ListMessagesResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns a list of messages for a given thread.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ApiResponse<ListMessagesResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun listMessagesWithHttpInfo(
    threadId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListMessages?,
    after: kotlin.String?,
    before: kotlin.String?
  ): ApiResponse<ListMessagesResponse?> {
    val localVariableConfig =
      listMessagesRequestConfig(
        threadId = threadId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return request<Unit, ListMessagesResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation listMessages
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return RequestConfig
   */
  fun listMessagesRequestConfig(
    threadId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListMessages?,
    after: kotlin.String?,
    before: kotlin.String?
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap =
      mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
        if (limit != null) {
          put("limit", listOf(limit.toString()))
        }
        if (order != null) {
          put("order", listOf(order.value))
        }
        if (after != null) {
          put("after", listOf(after.toString()))
        }
        if (before != null) {
          put("before", listOf(before.toString()))
        }
      }
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}/messages"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /** enum for parameter order */
  enum class OrderListRunSteps(val value: kotlin.String) {
    @SerialName(value = "asc") asc("asc"),
    @SerialName(value = "desc") desc("desc")
  }

  /**
   * Returns a list of run steps belonging to a run.
   *
   * @param threadId The ID of the thread the run and run steps belong to.
   * @param runId The ID of the run the run steps belong to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ListRunStepsResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun listRunSteps(
    threadId: kotlin.String,
    runId: kotlin.String,
    limit: kotlin.Int? = 20,
    order: OrderListRunSteps? = OrderListRunSteps.desc,
    after: kotlin.String? = null,
    before: kotlin.String? = null
  ): ListRunStepsResponse {
    val localVarResponse =
      listRunStepsWithHttpInfo(
        threadId = threadId,
        runId = runId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ListRunStepsResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns a list of run steps belonging to a run.
   *
   * @param threadId The ID of the thread the run and run steps belong to.
   * @param runId The ID of the run the run steps belong to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ApiResponse<ListRunStepsResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun listRunStepsWithHttpInfo(
    threadId: kotlin.String,
    runId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListRunSteps?,
    after: kotlin.String?,
    before: kotlin.String?
  ): ApiResponse<ListRunStepsResponse?> {
    val localVariableConfig =
      listRunStepsRequestConfig(
        threadId = threadId,
        runId = runId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return request<Unit, ListRunStepsResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation listRunSteps
   *
   * @param threadId The ID of the thread the run and run steps belong to.
   * @param runId The ID of the run the run steps belong to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return RequestConfig
   */
  fun listRunStepsRequestConfig(
    threadId: kotlin.String,
    runId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListRunSteps?,
    after: kotlin.String?,
    before: kotlin.String?
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap =
      mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
        if (limit != null) {
          put("limit", listOf(limit.toString()))
        }
        if (order != null) {
          put("order", listOf(order.value))
        }
        if (after != null) {
          put("after", listOf(after.toString()))
        }
        if (before != null) {
          put("before", listOf(before.toString()))
        }
      }
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}/runs/{run_id}/steps"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "run_id" + "}", encodeURIComponent(runId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /** enum for parameter order */
  enum class OrderListRuns(val value: kotlin.String) {
    @SerialName(value = "asc") asc("asc"),
    @SerialName(value = "desc") desc("desc")
  }

  /**
   * Returns a list of runs belonging to a thread.
   *
   * @param threadId The ID of the thread the run belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ListRunsResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun listRuns(
    threadId: kotlin.String,
    limit: kotlin.Int? = 20,
    order: OrderListRuns? = OrderListRuns.desc,
    after: kotlin.String? = null,
    before: kotlin.String? = null
  ): ListRunsResponse {
    val localVarResponse =
      listRunsWithHttpInfo(
        threadId = threadId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ListRunsResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns a list of runs belonging to a thread.
   *
   * @param threadId The ID of the thread the run belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return ApiResponse<ListRunsResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun listRunsWithHttpInfo(
    threadId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListRuns?,
    after: kotlin.String?,
    before: kotlin.String?
  ): ApiResponse<ListRunsResponse?> {
    val localVariableConfig =
      listRunsRequestConfig(
        threadId = threadId,
        limit = limit,
        order = order,
        after = after,
        before = before
      )

    return request<Unit, ListRunsResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation listRuns
   *
   * @param threadId The ID of the thread the run belongs to.
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and
   *   100, and the default is 20. (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60;
   *   for ascending order and &#x60;desc&#x60; for descending order. (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch
   *   the next page of the list. (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines
   *   your place in the list. For instance, if you make a list request and receive 100 objects,
   *   ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch
   *   the previous page of the list. (optional)
   * @return RequestConfig
   */
  fun listRunsRequestConfig(
    threadId: kotlin.String,
    limit: kotlin.Int?,
    order: OrderListRuns?,
    after: kotlin.String?,
    before: kotlin.String?
  ): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap =
      mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
        if (limit != null) {
          put("limit", listOf(limit.toString()))
        }
        if (order != null) {
          put("order", listOf(order.value))
        }
        if (after != null) {
          put("after", listOf(after.toString()))
        }
        if (before != null) {
          put("before", listOf(before.toString()))
        }
      }
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/threads/{thread_id}/runs"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Modifies an assistant.
   *
   * @param assistantId The ID of the assistant to modify.
   * @param modifyAssistantRequest
   * @return AssistantObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun modifyAssistant(
    assistantId: kotlin.String,
    modifyAssistantRequest: ModifyAssistantRequest
  ): AssistantObject {
    val localVarResponse =
      modifyAssistantWithHttpInfo(
        assistantId = assistantId,
        modifyAssistantRequest = modifyAssistantRequest
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as AssistantObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Modifies an assistant.
   *
   * @param assistantId The ID of the assistant to modify.
   * @param modifyAssistantRequest
   * @return ApiResponse<AssistantObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun modifyAssistantWithHttpInfo(
    assistantId: kotlin.String,
    modifyAssistantRequest: ModifyAssistantRequest
  ): ApiResponse<AssistantObject?> {
    val localVariableConfig =
      modifyAssistantRequestConfig(
        assistantId = assistantId,
        modifyAssistantRequest = modifyAssistantRequest
      )

    return request<ModifyAssistantRequest, AssistantObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation modifyAssistant
   *
   * @param assistantId The ID of the assistant to modify.
   * @param modifyAssistantRequest
   * @return RequestConfig
   */
  fun modifyAssistantRequestConfig(
    assistantId: kotlin.String,
    modifyAssistantRequest: ModifyAssistantRequest
  ): RequestConfig<ModifyAssistantRequest> {
    val localVariableBody = modifyAssistantRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/assistants/{assistant_id}"
          .replace("{" + "assistant_id" + "}", encodeURIComponent(assistantId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Modifies a message.
   *
   * @param threadId The ID of the thread to which this message belongs.
   * @param messageId The ID of the message to modify.
   * @param modifyMessageRequest
   * @return MessageObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun modifyMessage(
    threadId: kotlin.String,
    messageId: kotlin.String,
    modifyMessageRequest: ModifyMessageRequest
  ): MessageObject {
    val localVarResponse =
      modifyMessageWithHttpInfo(
        threadId = threadId,
        messageId = messageId,
        modifyMessageRequest = modifyMessageRequest
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as MessageObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Modifies a message.
   *
   * @param threadId The ID of the thread to which this message belongs.
   * @param messageId The ID of the message to modify.
   * @param modifyMessageRequest
   * @return ApiResponse<MessageObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun modifyMessageWithHttpInfo(
    threadId: kotlin.String,
    messageId: kotlin.String,
    modifyMessageRequest: ModifyMessageRequest
  ): ApiResponse<MessageObject?> {
    val localVariableConfig =
      modifyMessageRequestConfig(
        threadId = threadId,
        messageId = messageId,
        modifyMessageRequest = modifyMessageRequest
      )

    return request<ModifyMessageRequest, MessageObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation modifyMessage
   *
   * @param threadId The ID of the thread to which this message belongs.
   * @param messageId The ID of the message to modify.
   * @param modifyMessageRequest
   * @return RequestConfig
   */
  fun modifyMessageRequestConfig(
    threadId: kotlin.String,
    messageId: kotlin.String,
    modifyMessageRequest: ModifyMessageRequest
  ): RequestConfig<ModifyMessageRequest> {
    val localVariableBody = modifyMessageRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/threads/{thread_id}/messages/{message_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "message_id" + "}", encodeURIComponent(messageId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Modifies a run.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
   * @param runId The ID of the run to modify.
   * @param modifyRunRequest
   * @return RunObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun modifyRun(
    threadId: kotlin.String,
    runId: kotlin.String,
    modifyRunRequest: ModifyRunRequest
  ): RunObject {
    val localVarResponse =
      modifyRunWithHttpInfo(threadId = threadId, runId = runId, modifyRunRequest = modifyRunRequest)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Modifies a run.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
   * @param runId The ID of the run to modify.
   * @param modifyRunRequest
   * @return ApiResponse<RunObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun modifyRunWithHttpInfo(
    threadId: kotlin.String,
    runId: kotlin.String,
    modifyRunRequest: ModifyRunRequest
  ): ApiResponse<RunObject?> {
    val localVariableConfig =
      modifyRunRequestConfig(
        threadId = threadId,
        runId = runId,
        modifyRunRequest = modifyRunRequest
      )

    return request<ModifyRunRequest, RunObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation modifyRun
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
   * @param runId The ID of the run to modify.
   * @param modifyRunRequest
   * @return RequestConfig
   */
  fun modifyRunRequestConfig(
    threadId: kotlin.String,
    runId: kotlin.String,
    modifyRunRequest: ModifyRunRequest
  ): RequestConfig<ModifyRunRequest> {
    val localVariableBody = modifyRunRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/threads/{thread_id}/runs/{run_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "run_id" + "}", encodeURIComponent(runId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Modifies a thread.
   *
   * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
   * @param modifyThreadRequest
   * @return ThreadObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun modifyThread(
    threadId: kotlin.String,
    modifyThreadRequest: ModifyThreadRequest
  ): ThreadObject {
    val localVarResponse =
      modifyThreadWithHttpInfo(threadId = threadId, modifyThreadRequest = modifyThreadRequest)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ThreadObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Modifies a thread.
   *
   * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
   * @param modifyThreadRequest
   * @return ApiResponse<ThreadObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun modifyThreadWithHttpInfo(
    threadId: kotlin.String,
    modifyThreadRequest: ModifyThreadRequest
  ): ApiResponse<ThreadObject?> {
    val localVariableConfig =
      modifyThreadRequestConfig(threadId = threadId, modifyThreadRequest = modifyThreadRequest)

    return request<ModifyThreadRequest, ThreadObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation modifyThread
   *
   * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
   * @param modifyThreadRequest
   * @return RequestConfig
   */
  fun modifyThreadRequestConfig(
    threadId: kotlin.String,
    modifyThreadRequest: ModifyThreadRequest
  ): RequestConfig<ModifyThreadRequest> {
    val localVariableBody = modifyThreadRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/threads/{thread_id}"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and
   * &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used
   * to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be
   * submitted in a single request.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
   * @param runId The ID of the run that requires the tool output submission.
   * @param submitToolOutputsRunRequest
   * @return RunObject
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun submitToolOuputsToRun(
    threadId: kotlin.String,
    runId: kotlin.String,
    submitToolOutputsRunRequest: SubmitToolOutputsRunRequest
  ): RunObject {
    val localVarResponse =
      submitToolOuputsToRunWithHttpInfo(
        threadId = threadId,
        runId = runId,
        submitToolOutputsRunRequest = submitToolOutputsRunRequest
      )

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and
   * &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used
   * to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be
   * submitted in a single request.
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
   * @param runId The ID of the run that requires the tool output submission.
   * @param submitToolOutputsRunRequest
   * @return ApiResponse<RunObject?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun submitToolOuputsToRunWithHttpInfo(
    threadId: kotlin.String,
    runId: kotlin.String,
    submitToolOutputsRunRequest: SubmitToolOutputsRunRequest
  ): ApiResponse<RunObject?> {
    val localVariableConfig =
      submitToolOuputsToRunRequestConfig(
        threadId = threadId,
        runId = runId,
        submitToolOutputsRunRequest = submitToolOutputsRunRequest
      )

    return request<SubmitToolOutputsRunRequest, RunObject>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation submitToolOuputsToRun
   *
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
   * @param runId The ID of the run that requires the tool output submission.
   * @param submitToolOutputsRunRequest
   * @return RequestConfig
   */
  fun submitToolOuputsToRunRequestConfig(
    threadId: kotlin.String,
    runId: kotlin.String,
    submitToolOutputsRunRequest: SubmitToolOutputsRunRequest
  ): RequestConfig<SubmitToolOutputsRunRequest> {
    val localVariableBody = submitToolOutputsRunRequest
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Content-Type"] = "application/json"
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path =
        "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs"
          .replace("{" + "thread_id" + "}", encodeURIComponent(threadId.toString()))
          .replace("{" + "run_id" + "}", encodeURIComponent(runId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
    HttpUrl.Builder()
      .scheme("http")
      .host("localhost")
      .addPathSegment(uriComponent)
      .build()
      .encodedPathSegments[0]
}
