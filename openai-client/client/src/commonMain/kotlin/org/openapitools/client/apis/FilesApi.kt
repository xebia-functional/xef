/**
 * Please note: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
@file:Suppress("ArrayInDataClass", "EnumEntryName", "RemoveRedundantQualifierName", "UnusedImport")

package org.openapitools.client.apis

import com.xebia.functional.openai.model.DeleteFileResponse
import com.xebia.functional.openai.model.ListFilesResponse
import com.xebia.functional.openai.model.OpenAIFile
import java.io.IOException
import kotlinx.serialization.SerialName
import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.Success

class FilesApi(
  basePath: kotlin.String = defaultBasePath,
  client: OkHttpClient = ApiClient.defaultClient
) : ApiClient(basePath, client) {
  companion object {
    @JvmStatic
    val defaultBasePath: String by lazy {
      System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.openai.com/v1")
    }
  }

  /** enum for parameter purpose */
  enum class PurposeCreateFile(val value: kotlin.String) {
    @SerialName(value = "fine-tune") fine_tune("fine-tune"),
    @SerialName(value = "assistants") assistants("assistants")
  }

  /**
   * Upload a file that can be used across various endpoints. The size of all the files uploaded by
   * one organization can be up to 100 GB. The size of individual files can be a maximum of 512 MB
   * or 2 million tokens for Assistants. See the [Assistants Tools guide](/docs/assistants/tools) to
   * learn more about the types of files supported. The Fine-tuning API only supports
   * &#x60;.jsonl&#x60; files. Please [contact us](https://help.openai.com/) if you need to increase
   * these storage limits.
   *
   * @param file The File object (not file name) to be uploaded.
   * @param purpose The intended purpose of the uploaded file. Use \\\&quot;fine-tune\\\&quot; for
   *   [Fine-tuning](/docs/api-reference/fine-tuning) and \\\&quot;assistants\\\&quot; for
   *   [Assistants](/docs/api-reference/assistants) and [Messages](/docs/api-reference/messages).
   *   This allows us to validate the format of the uploaded file is correct for fine-tuning.
   * @return OpenAIFile
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun createFile(file: java.io.File, purpose: PurposeCreateFile): OpenAIFile {
    val localVarResponse = createFileWithHttpInfo(file = file, purpose = purpose)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as OpenAIFile
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Upload a file that can be used across various endpoints. The size of all the files uploaded by
   * one organization can be up to 100 GB. The size of individual files can be a maximum of 512 MB
   * or 2 million tokens for Assistants. See the [Assistants Tools guide](/docs/assistants/tools) to
   * learn more about the types of files supported. The Fine-tuning API only supports
   * &#x60;.jsonl&#x60; files. Please [contact us](https://help.openai.com/) if you need to increase
   * these storage limits.
   *
   * @param file The File object (not file name) to be uploaded.
   * @param purpose The intended purpose of the uploaded file. Use \\\&quot;fine-tune\\\&quot; for
   *   [Fine-tuning](/docs/api-reference/fine-tuning) and \\\&quot;assistants\\\&quot; for
   *   [Assistants](/docs/api-reference/assistants) and [Messages](/docs/api-reference/messages).
   *   This allows us to validate the format of the uploaded file is correct for fine-tuning.
   * @return ApiResponse<OpenAIFile?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun createFileWithHttpInfo(
    file: java.io.File,
    purpose: PurposeCreateFile
  ): ApiResponse<OpenAIFile?> {
    val localVariableConfig = createFileRequestConfig(file = file, purpose = purpose)

    return request<Map<String, PartConfig<*>>, OpenAIFile>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation createFile
   *
   * @param file The File object (not file name) to be uploaded.
   * @param purpose The intended purpose of the uploaded file. Use \\\&quot;fine-tune\\\&quot; for
   *   [Fine-tuning](/docs/api-reference/fine-tuning) and \\\&quot;assistants\\\&quot; for
   *   [Assistants](/docs/api-reference/assistants) and [Messages](/docs/api-reference/messages).
   *   This allows us to validate the format of the uploaded file is correct for fine-tuning.
   * @return RequestConfig
   */
  fun createFileRequestConfig(
    file: java.io.File,
    purpose: PurposeCreateFile
  ): RequestConfig<Map<String, PartConfig<*>>> {
    val localVariableBody =
      mapOf(
        "file" to PartConfig(body = file, headers = mutableMapOf()),
        "purpose" to PartConfig(body = purpose.value, headers = mutableMapOf()),
      )
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> =
      mutableMapOf("Content-Type" to "multipart/form-data")
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.POST,
      path = "/files",
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Delete a file.
   *
   * @param fileId The ID of the file to use for this request.
   * @return DeleteFileResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun deleteFile(fileId: kotlin.String): DeleteFileResponse {
    val localVarResponse = deleteFileWithHttpInfo(fileId = fileId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteFileResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Delete a file.
   *
   * @param fileId The ID of the file to use for this request.
   * @return ApiResponse<DeleteFileResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun deleteFileWithHttpInfo(fileId: kotlin.String): ApiResponse<DeleteFileResponse?> {
    val localVariableConfig = deleteFileRequestConfig(fileId = fileId)

    return request<Unit, DeleteFileResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation deleteFile
   *
   * @param fileId The ID of the file to use for this request.
   * @return RequestConfig
   */
  fun deleteFileRequestConfig(fileId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.DELETE,
      path =
        "/files/{file_id}".replace("{" + "file_id" + "}", encodeURIComponent(fileId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Returns the contents of the specified file.
   *
   * @param fileId The ID of the file to use for this request.
   * @return kotlin.String
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun downloadFile(fileId: kotlin.String): kotlin.String {
    val localVarResponse = downloadFileWithHttpInfo(fileId = fileId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns the contents of the specified file.
   *
   * @param fileId The ID of the file to use for this request.
   * @return ApiResponse<kotlin.String?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun downloadFileWithHttpInfo(fileId: kotlin.String): ApiResponse<kotlin.String?> {
    val localVariableConfig = downloadFileRequestConfig(fileId = fileId)

    return request<Unit, kotlin.String>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation downloadFile
   *
   * @param fileId The ID of the file to use for this request.
   * @return RequestConfig
   */
  fun downloadFileRequestConfig(fileId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/files/{file_id}/content"
          .replace("{" + "file_id" + "}", encodeURIComponent(fileId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Returns a list of files that belong to the user&#39;s organization.
   *
   * @param purpose Only return files with the given purpose. (optional)
   * @return ListFilesResponse
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun listFiles(purpose: kotlin.String? = null): ListFilesResponse {
    val localVarResponse = listFilesWithHttpInfo(purpose = purpose)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as ListFilesResponse
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns a list of files that belong to the user&#39;s organization.
   *
   * @param purpose Only return files with the given purpose. (optional)
   * @return ApiResponse<ListFilesResponse?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun listFilesWithHttpInfo(purpose: kotlin.String?): ApiResponse<ListFilesResponse?> {
    val localVariableConfig = listFilesRequestConfig(purpose = purpose)

    return request<Unit, ListFilesResponse>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation listFiles
   *
   * @param purpose Only return files with the given purpose. (optional)
   * @return RequestConfig
   */
  fun listFilesRequestConfig(purpose: kotlin.String?): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap =
      mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
        if (purpose != null) {
          put("purpose", listOf(purpose.toString()))
        }
      }
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path = "/files",
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  /**
   * Returns information about a specific file.
   *
   * @param fileId The ID of the file to use for this request.
   * @return OpenAIFile
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   * @throws UnsupportedOperationException If the API returns an informational or redirection
   *   response
   * @throws ClientException If the API returns a client error response
   * @throws ServerException If the API returns a server error response
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(
    IllegalStateException::class,
    IOException::class,
    UnsupportedOperationException::class,
    ClientException::class,
    ServerException::class
  )
  fun retrieveFile(fileId: kotlin.String): OpenAIFile {
    val localVarResponse = retrieveFileWithHttpInfo(fileId = fileId)

    return when (localVarResponse.responseType) {
      ResponseType.Success -> (localVarResponse as Success<*>).data as OpenAIFile
      ResponseType.Informational ->
        throw UnsupportedOperationException("Client does not support Informational responses.")
      ResponseType.Redirection ->
        throw UnsupportedOperationException("Client does not support Redirection responses.")
      ResponseType.ClientError -> {
        val localVarError = localVarResponse as ClientError<*>
        throw ClientException(
          "Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}",
          localVarError.statusCode,
          localVarResponse
        )
      }
      ResponseType.ServerError -> {
        val localVarError = localVarResponse as ServerError<*>
        throw ServerException(
          "Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}",
          localVarError.statusCode,
          localVarResponse
        )
      }
    }
  }

  /**
   * Returns information about a specific file.
   *
   * @param fileId The ID of the file to use for this request.
   * @return ApiResponse<OpenAIFile?>
   * @throws IllegalStateException If the request is not correctly configured
   * @throws IOException Rethrows the OkHttp execute method exception
   */
  @Suppress("UNCHECKED_CAST")
  @Throws(IllegalStateException::class, IOException::class)
  fun retrieveFileWithHttpInfo(fileId: kotlin.String): ApiResponse<OpenAIFile?> {
    val localVariableConfig = retrieveFileRequestConfig(fileId = fileId)

    return request<Unit, OpenAIFile>(localVariableConfig)
  }

  /**
   * To obtain the request config of the operation retrieveFile
   *
   * @param fileId The ID of the file to use for this request.
   * @return RequestConfig
   */
  fun retrieveFileRequestConfig(fileId: kotlin.String): RequestConfig<Unit> {
    val localVariableBody = null
    val localVariableQuery: MultiValueMap = mutableMapOf()
    val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
    localVariableHeaders["Accept"] = "application/json"

    return RequestConfig(
      method = RequestMethod.GET,
      path =
        "/files/{file_id}".replace("{" + "file_id" + "}", encodeURIComponent(fileId.toString())),
      query = localVariableQuery,
      headers = localVariableHeaders,
      requiresAuthentication = true,
      body = localVariableBody
    )
  }

  private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
    HttpUrl.Builder()
      .scheme("http")
      .host("localhost")
      .addPathSegment(uriComponent)
      .build()
      .encodedPathSegments[0]
}
